General idea:

build a kd-tree implementation in C or C++ with python bindings.

the goal is to be able to use it for efficient NN search or kNN search

Question 1: How will I use TDD with this?

Ramble Answer 1:

	I want to imagine what I want to do with this tree.

	Typically, I want to do something like this:

	tree = new KDTree()
	for point in random_points(N):
		tree.add(point, randomValue)
	typical mapping stuff:
	pt in tree
    tree[pt]
	tree.delete(pt)
	len(tree)
	nearest_point = tree.nnsearch(pt)
	
	It looks like each of these functions could be something like a test

Ramble Answer 2:
  
	Could this be BDD?
	
Next steps:

	Well, the implementation I have so far seems to be doing what I want, and it should be enough to make a first attempt at improving the speed of doing a bunch of simple nearest-neighbor lookups. There are also some more tests that would be nice to have in cxxtest.

- python bindings #TOP PRIORITY#
- iterator traversal / deleting within iterator context (?)
- random-based test, lots of insertions and deletions and some nearest node checks?
- performance measurements for random data to verify O(log n) nn lookup.
  * it would be nice to have these in both C and Python to see if there's a nasty python overhead, once the bindings are in place


Update:

There is now:
- a decently complete python binding (tested)
- iterator traversal (but not in python)
- and manual tests to indicate we are actually operating efficiently

But now the goal is to get really fast rendering of the following algorithm:
- each point in the tree has a single color associated with it
- for each pixel in an image (at a given x, y position),
	* find the nn point to that pixel
	* pixel color = point color

So we want to add a method to the kdtree python object that will do this rendering:

KDTree_render_simple(KDTree *self, PyObject *args)

which implements something like 

KDTree_render_simple(KDTree *self, PyArrayObject *arr)

Assumptions:
	arr is of size (l, w, 3) X <type>
	all the objects stored in the KDTree are array objects of size (3) X <type>
	
Algorithm:
	enforce assumptions on arr
	for i in xrange(l):
		for j in xrange(w):
			color = kdtree_nn(self.kdt, i, j)
			enforce assumptions on color
			arr[i, j, :] = color


